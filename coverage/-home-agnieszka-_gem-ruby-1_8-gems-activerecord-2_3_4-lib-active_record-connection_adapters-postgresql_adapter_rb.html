<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/home/agnieszka/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/connection_adapters/postgresql_adapter.rb</title>
    <link href="screen.css" media="all" rel="stylesheet" type="text/css" />
    <link href="print.css" media="print" rel="stylesheet" type="text/css" />
    
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h1>Serwis Aukcyjny 2 C0 Coverage Information - RCov</h1>
    <h2>/home/agnieszka/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/connection_adapters/postgresql_adapter.rb</h2>

    

    <div class="report_table_wrapper">
      <table class='report' id='report_table'>
        <thead>
          <tr>
            <th class="left_align">Name</th>
            <th class="right_align">Total Lines</th>
            <th class="right_align">Lines of Code</th>
            <th class="left_align">Total Coverage</th>
            <th class="left_align">Code Coverage</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="left_align"><a href="-home-agnieszka-_gem-ruby-1_8-gems-activerecord-2_3_4-lib-active_record-connection_adapters-postgresql_adapter_rb.html">/home/agnieszka/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/connection_adapters/postgresql_adapter.rb</a></td>
            <td class='right_align'><tt>1113</tt></td>
            <td class='right_align'><tt>768</tt></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>71.34%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:71px"></div>
            <div class="uncovered" style="width:29px"></div>
          </div></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>63.28%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:63px"></div>
            <div class="uncovered" style="width:37px"></div>
          </div></td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <h3>Key</h3>
    
    <div class="key"><pre><span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here's a line marked as not executed.</span></pre></div>

    <h3>Coverage Details</h3>

    <table class="details">
      <tbody>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1">1</a> require 'active_record/connection_adapters/abstract_adapter'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2">2</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3">3</a> begin</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line4">4</a>   require_library_or_gem 'pg'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line5">5</a> rescue LoadError =&gt; e</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line6">6</a>   begin</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line7">7</a>     require_library_or_gem 'postgres'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line8">8</a>     class PGresult</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line9">9</a>       alias_method :nfields, :num_fields unless self.method_defined?(:nfields)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line10">10</a>       alias_method :ntuples, :num_tuples unless self.method_defined?(:ntuples)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line11">11</a>       alias_method :ftype, :type unless self.method_defined?(:ftype)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line12">12</a>       alias_method :cmd_tuples, :cmdtuples unless self.method_defined?(:cmd_tuples)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line13">13</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line14">14</a>   rescue LoadError</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line15">15</a>     raise e</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line16">16</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line17">17</a> end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line18">18</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line19">19</a> module ActiveRecord</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line20">20</a>   class Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line21">21</a>     # Establishes a connection to the database that's used by all Active Record objects</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line22">22</a>     def self.postgresql_connection(config) # :nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line23">23</a>       config = config.symbolize_keys</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line24">24</a>       host     = config[:host]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line25">25</a>       port     = config[:port] || 5432</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line26">26</a>       username = config[:username].to_s if config[:username]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line27">27</a>       password = config[:password].to_s if config[:password]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line28">28</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line29">29</a>       if config.has_key?(:database)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line30">30</a>         database = config[:database]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line31">31</a>       else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line32">32</a>         raise ArgumentError, &quot;No database specified. Missing argument: database.&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line33">33</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line34">34</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line35">35</a>       # The postgres drivers don't allow the creation of an unconnected PGconn object,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line36">36</a>       # so just pass a nil connection object for the time being.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line37">37</a>       ConnectionAdapters::PostgreSQLAdapter.new(nil, logger, [host, port, nil, nil, database, username, password], config)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line38">38</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line39">39</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line40">40</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line41">41</a>   module ConnectionAdapters</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line42">42</a>     class TableDefinition</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line43">43</a>       def xml(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line44">44</a>         options = args.extract_options!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line45">45</a>         column(args[0], 'xml', options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line46">46</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line47">47</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line48">48</a>     # PostgreSQL-specific extensions to column definitions in a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line49">49</a>     class PostgreSQLColumn &lt; Column #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line50">50</a>       # Instantiates a new PostgreSQL column definition in a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line51">51</a>       def initialize(name, default, sql_type = nil, null = true)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line52">52</a>         super(name, self.class.extract_value_from_default(default), sql_type, null)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line53">53</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line54">54</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line55">55</a>       private</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line56">56</a>         def extract_limit(sql_type)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line57">57</a>           case sql_type</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line58">58</a>           when /^bigint/i;    8</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line59">59</a>           when /^smallint/i;  2</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line60">60</a>           else super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line61">61</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line62">62</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line63">63</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line64">64</a>         # Extracts the scale from PostgreSQL-specific data types.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line65">65</a>         def extract_scale(sql_type)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line66">66</a>           # Money type has a fixed scale of 2.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line67">67</a>           sql_type =~ /^money/ ? 2 : super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line68">68</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line69">69</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line70">70</a>         # Extracts the precision from PostgreSQL-specific data types.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line71">71</a>         def extract_precision(sql_type)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line72">72</a>           # Actual code is defined dynamically in PostgreSQLAdapter.connect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line73">73</a>           # depending on the server specifics</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line74">74</a>           super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line75">75</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line76">76</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line77">77</a>         # Maps PostgreSQL-specific data types to logical Rails types.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line78">78</a>         def simplified_type(field_type)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line79">79</a>           case field_type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line80">80</a>             # Numeric and monetary types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line81">81</a>             when /^(?:real|double precision)$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line82">82</a>               :float</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line83">83</a>             # Monetary types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line84">84</a>             when /^money$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line85">85</a>               :decimal</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line86">86</a>             # Character types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line87">87</a>             when /^(?:character varying|bpchar)(?:\(\d+\))?$/</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line88">88</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line89">89</a>             # Binary data types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line90">90</a>             when /^bytea$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line91">91</a>               :binary</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line92">92</a>             # Date/time types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line93">93</a>             when /^timestamp with(?:out)? time zone$/</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line94">94</a>               :datetime</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line95">95</a>             when /^interval$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line96">96</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line97">97</a>             # Geometric types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line98">98</a>             when /^(?:point|line|lseg|box|&quot;?path&quot;?|polygon|circle)$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line99">99</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line100">100</a>             # Network address types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line101">101</a>             when /^(?:cidr|inet|macaddr)$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line102">102</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line103">103</a>             # Bit strings</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line104">104</a>             when /^bit(?: varying)?(?:\(\d+\))?$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line105">105</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line106">106</a>             # XML type</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line107">107</a>             when /^xml$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line108">108</a>               :xml</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line109">109</a>             # Arrays</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line110">110</a>             when /^\D+\[\]$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line111">111</a>               :string</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line112">112</a>             # Object identifier types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line113">113</a>             when /^oid$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line114">114</a>               :integer</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line115">115</a>             # Pass through all types that are not specific to PostgreSQL.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line116">116</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line117">117</a>               super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line118">118</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line119">119</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line120">120</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line121">121</a>         # Extracts the value from a PostgreSQL column default definition.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line122">122</a>         def self.extract_value_from_default(default)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line123">123</a>           case default</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line124">124</a>             # Numeric types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line125">125</a>             when /\A\(?(-?\d+(\.\d*)?\)?)\z/</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line126">126</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line127">127</a>             # Character types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line128">128</a>             when /\A'(.*)'::(?:character varying|bpchar|text)\z/m</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line129">129</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line130">130</a>             # Character types (8.1 formatting)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line131">131</a>             when /\AE'(.*)'::(?:character varying|bpchar|text)\z/m</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line132">132</a>               $1.gsub(/\\(\d\d\d)/) { $1.oct.chr }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line133">133</a>             # Binary data types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line134">134</a>             when /\A'(.*)'::bytea\z/m</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line135">135</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line136">136</a>             # Date/time types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line137">137</a>             when /\A'(.+)'::(?:time(?:stamp)? with(?:out)? time zone|date)\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line138">138</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line139">139</a>             when /\A'(.*)'::interval\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line140">140</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line141">141</a>             # Boolean type</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line142">142</a>             when 'true'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line143">143</a>               true</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line144">144</a>             when 'false'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line145">145</a>               false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line146">146</a>             # Geometric types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line147">147</a>             when /\A'(.*)'::(?:point|line|lseg|box|&quot;?path&quot;?|polygon|circle)\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line148">148</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line149">149</a>             # Network address types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line150">150</a>             when /\A'(.*)'::(?:cidr|inet|macaddr)\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line151">151</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line152">152</a>             # Bit string types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line153">153</a>             when /\AB'(.*)'::&quot;?bit(?: varying)?&quot;?\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line154">154</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line155">155</a>             # XML type</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line156">156</a>             when /\A'(.*)'::xml\z/m</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line157">157</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line158">158</a>             # Arrays</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line159">159</a>             when /\A'(.*)'::&quot;?\D+&quot;?\[\]\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line160">160</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line161">161</a>             # Object identifier types</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line162">162</a>             when /\A-?\d+\z/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line163">163</a>               $1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line164">164</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line165">165</a>               # Anything else is blank, some user type, or some function</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line166">166</a>               # and we can't know the value of that, so return nil.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line167">167</a>               nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line168">168</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line169">169</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line170">170</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line171">171</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line172">172</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line173">173</a>   module ConnectionAdapters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line174">174</a>     # The PostgreSQL adapter works both with the native C (http://ruby.scripting.ca/postgres/) and the pure</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line175">175</a>     # Ruby (available both as gem and from http://rubyforge.org/frs/?group_id=234&amp;release_id=1944) drivers.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line176">176</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line177">177</a>     # Options:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line178">178</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line179">179</a>     # * &lt;tt&gt;:host&lt;/tt&gt; - Defaults to &quot;localhost&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line180">180</a>     # * &lt;tt&gt;:port&lt;/tt&gt; - Defaults to 5432.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line181">181</a>     # * &lt;tt&gt;:username&lt;/tt&gt; - Defaults to nothing.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line182">182</a>     # * &lt;tt&gt;:password&lt;/tt&gt; - Defaults to nothing.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line183">183</a>     # * &lt;tt&gt;:database&lt;/tt&gt; - The name of the database. No default, must be provided.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line184">184</a>     # * &lt;tt&gt;:schema_search_path&lt;/tt&gt; - An optional schema search path for the connection given as a string of comma-separated schema names.  This is backward-compatible with the &lt;tt&gt;:schema_order&lt;/tt&gt; option.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line185">185</a>     # * &lt;tt&gt;:encoding&lt;/tt&gt; - An optional client encoding that is used in a &lt;tt&gt;SET client_encoding TO &lt;encoding&gt;&lt;/tt&gt; call on the connection.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line186">186</a>     # * &lt;tt&gt;:min_messages&lt;/tt&gt; - An optional client min messages that is used in a &lt;tt&gt;SET client_min_messages TO &lt;min_messages&gt;&lt;/tt&gt; call on the connection.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line187">187</a>     # * &lt;tt&gt;:allow_concurrency&lt;/tt&gt; - If true, use async query methods so Ruby threads don't deadlock; otherwise, use blocking query methods.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line188">188</a>     class PostgreSQLAdapter &lt; AbstractAdapter</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line189">189</a>       ADAPTER_NAME = 'PostgreSQL'.freeze</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line190">190</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line191">191</a>       NATIVE_DATABASE_TYPES = {</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line192">192</a>         :primary_key =&gt; &quot;serial primary key&quot;.freeze,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line193">193</a>         :string      =&gt; { :name =&gt; &quot;character varying&quot;, :limit =&gt; 255 },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line194">194</a>         :text        =&gt; { :name =&gt; &quot;text&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line195">195</a>         :integer     =&gt; { :name =&gt; &quot;integer&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line196">196</a>         :float       =&gt; { :name =&gt; &quot;float&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line197">197</a>         :decimal     =&gt; { :name =&gt; &quot;decimal&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line198">198</a>         :datetime    =&gt; { :name =&gt; &quot;timestamp&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line199">199</a>         :timestamp   =&gt; { :name =&gt; &quot;timestamp&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line200">200</a>         :time        =&gt; { :name =&gt; &quot;time&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line201">201</a>         :date        =&gt; { :name =&gt; &quot;date&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line202">202</a>         :binary      =&gt; { :name =&gt; &quot;bytea&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line203">203</a>         :boolean     =&gt; { :name =&gt; &quot;boolean&quot; },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line204">204</a>         :xml         =&gt; { :name =&gt; &quot;xml&quot; }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line205">205</a>       }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line206">206</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line207">207</a>       # Returns 'PostgreSQL' as adapter name for identification purposes.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line208">208</a>       def adapter_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line209">209</a>         ADAPTER_NAME</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line210">210</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line211">211</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line212">212</a>       # Initializes and connects a PostgreSQL adapter.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line213">213</a>       def initialize(connection, logger, connection_parameters, config)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line214">214</a>         super(connection, logger)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line215">215</a>         @connection_parameters, @config = connection_parameters, config</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line216">216</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line217">217</a>         connect</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line218">218</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line219">219</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line220">220</a>       # Is this connection alive and ready for queries?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line221">221</a>       def active?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line222">222</a>         if @connection.respond_to?(:status)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line223">223</a>           @connection.status == PGconn::CONNECTION_OK</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line224">224</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line225">225</a>           # We're asking the driver, not ActiveRecord, so use @connection.query instead of #query</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line226">226</a>           @connection.query 'SELECT 1'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line227">227</a>           true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line228">228</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line229">229</a>       # postgres-pr raises a NoMethodError when querying if no connection is available.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line230">230</a>       rescue PGError, NoMethodError</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line231">231</a>         false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line232">232</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line233">233</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line234">234</a>       # Close then reopen the connection.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line235">235</a>       def reconnect!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line236">236</a>         if @connection.respond_to?(:reset)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line237">237</a>           @connection.reset</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line238">238</a>           configure_connection</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line239">239</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line240">240</a>           disconnect!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line241">241</a>           connect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line242">242</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line243">243</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line244">244</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line245">245</a>       # Close the connection.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line246">246</a>       def disconnect!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line247">247</a>         @connection.close rescue nil</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line248">248</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line249">249</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line250">250</a>       def native_database_types #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line251">251</a>         NATIVE_DATABASE_TYPES</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line252">252</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line253">253</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line254">254</a>       # Does PostgreSQL support migrations?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line255">255</a>       def supports_migrations?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line256">256</a>         true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line257">257</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line258">258</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line259">259</a>       # Does PostgreSQL support finding primary key on non-ActiveRecord tables?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line260">260</a>       def supports_primary_key? #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line261">261</a>         true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line262">262</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line263">263</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line264">264</a>       # Does PostgreSQL support standard conforming strings?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line265">265</a>       def supports_standard_conforming_strings?</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line266">266</a>         # Temporarily set the client message level above error to prevent unintentional</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line267">267</a>         # error messages in the logs when working on a PostgreSQL database server that</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line268">268</a>         # does not support standard conforming strings.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line269">269</a>         client_min_messages_old = client_min_messages</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line270">270</a>         self.client_min_messages = 'panic'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line271">271</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line272">272</a>         # postgres-pr does not raise an exception when client_min_messages is set higher</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line273">273</a>         # than error and &quot;SHOW standard_conforming_strings&quot; fails, but returns an empty</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line274">274</a>         # PGresult instead.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line275">275</a>         has_support = query('SHOW standard_conforming_strings')[0][0] rescue false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line276">276</a>         self.client_min_messages = client_min_messages_old</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line277">277</a>         has_support</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line278">278</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line279">279</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line280">280</a>       def supports_insert_with_returning?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line281">281</a>         postgresql_version &gt;= 80200</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line282">282</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line283">283</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line284">284</a>       def supports_ddl_transactions?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line285">285</a>         true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line286">286</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line287">287</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line288">288</a>       def supports_savepoints?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line289">289</a>         true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line290">290</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line291">291</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line292">292</a>       # Returns the configured supported identifier length supported by PostgreSQL,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line293">293</a>       # or report the default of 63 on PostgreSQL 7.x.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line294">294</a>       def table_alias_length</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line295">295</a>         @table_alias_length ||= (postgresql_version &gt;= 80000 ? query('SHOW max_identifier_length')[0][0].to_i : 63)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line296">296</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line297">297</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line298">298</a>       # QUOTING ==================================================</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line299">299</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line300">300</a>       # Escapes binary strings for bytea input to the database.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line301">301</a>       def escape_bytea(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line302">302</a>         if @connection.respond_to?(:escape_bytea)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line303">303</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line304">304</a>             define_method(:escape_bytea) do |value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line305">305</a>               @connection.escape_bytea(value) if value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line306">306</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line307">307</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line308">308</a>         elsif PGconn.respond_to?(:escape_bytea)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line309">309</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line310">310</a>             define_method(:escape_bytea) do |value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line311">311</a>               PGconn.escape_bytea(value) if value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line312">312</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line313">313</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line314">314</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line315">315</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line316">316</a>             define_method(:escape_bytea) do |value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line317">317</a>               if value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line318">318</a>                 result = ''</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line319">319</a>                 value.each_byte { |c| result &lt;&lt; sprintf('\\\\%03o', c) }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line320">320</a>                 result</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line321">321</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line322">322</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line323">323</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line324">324</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line325">325</a>         escape_bytea(value)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line326">326</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line327">327</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line328">328</a>       # Unescapes bytea output from a database to the binary string it represents.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line329">329</a>       # NOTE: This is NOT an inverse of escape_bytea! This is only to be used</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line330">330</a>       #       on escaped binary output from database drive.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line331">331</a>       def unescape_bytea(value)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line332">332</a>         # In each case, check if the value actually is escaped PostgreSQL bytea output</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line333">333</a>         # or an unescaped Active Record attribute that was just written.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line334">334</a>         if PGconn.respond_to?(:unescape_bytea)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line335">335</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line336">336</a>             define_method(:unescape_bytea) do |value|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line337">337</a>               if value =~ /\\\d{3}/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line338">338</a>                 PGconn.unescape_bytea(value)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line339">339</a>               else</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line340">340</a>                 value</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line341">341</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line342">342</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line343">343</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line344">344</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line345">345</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line346">346</a>             define_method(:unescape_bytea) do |value|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line347">347</a>               if value =~ /\\\d{3}/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line348">348</a>                 result = ''</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line349">349</a>                 i, max = 0, value.size</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line350">350</a>                 while i &lt; max</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line351">351</a>                   char = value[i]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line352">352</a>                   if char == ?\\</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line353">353</a>                     if value[i+1] == ?\\</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line354">354</a>                       char = ?\\</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line355">355</a>                       i += 1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line356">356</a>                     else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line357">357</a>                       char = value[i+1..i+3].oct</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line358">358</a>                       i += 3</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line359">359</a>                     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line360">360</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line361">361</a>                   result &lt;&lt; char</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line362">362</a>                   i += 1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line363">363</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line364">364</a>                 result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line365">365</a>               else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line366">366</a>                 value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line367">367</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line368">368</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line369">369</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line370">370</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line371">371</a>         unescape_bytea(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line372">372</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line373">373</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line374">374</a>       # Quotes PostgreSQL-specific data types for SQL input.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line375">375</a>       def quote(value, column = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line376">376</a>         if value.kind_of?(String) &amp;&amp; column &amp;&amp; column.type == :binary</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line377">377</a>           &quot;#{quoted_string_prefix}'#{escape_bytea(value)}'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line378">378</a>         elsif value.kind_of?(String) &amp;&amp; column &amp;&amp; column.sql_type =~ /^xml$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line379">379</a>           &quot;xml E'#{quote_string(value)}'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line380">380</a>         elsif value.kind_of?(Numeric) &amp;&amp; column &amp;&amp; column.sql_type =~ /^money$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line381">381</a>           # Not truly string input, so doesn't require (or allow) escape string syntax.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line382">382</a>           &quot;'#{value.to_s}'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line383">383</a>         elsif value.kind_of?(String) &amp;&amp; column &amp;&amp; column.sql_type =~ /^bit/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line384">384</a>           case value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line385">385</a>             when /^[01]*$/</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line386">386</a>               &quot;B'#{value}'&quot; # Bit-string notation</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line387">387</a>             when /^[0-9A-F]*$/i</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line388">388</a>               &quot;X'#{value}'&quot; # Hexadecimal notation</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line389">389</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line390">390</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line391">391</a>           super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line392">392</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line393">393</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line394">394</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line395">395</a>       # Quotes strings for use in SQL input in the postgres driver for better performance.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line396">396</a>       def quote_string(s) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line397">397</a>         if @connection.respond_to?(:escape)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line398">398</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line399">399</a>             define_method(:quote_string) do |s|</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line400">400</a>               @connection.escape(s)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line401">401</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line402">402</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line403">403</a>         elsif PGconn.respond_to?(:escape)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line404">404</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line405">405</a>             define_method(:quote_string) do |s|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line406">406</a>               PGconn.escape(s)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line407">407</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line408">408</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line409">409</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line410">410</a>           # There are some incorrectly compiled postgres drivers out there</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line411">411</a>           # that don't define PGconn.escape.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line412">412</a>           self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line413">413</a>             remove_method(:quote_string)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line414">414</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line415">415</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line416">416</a>         quote_string(s)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line417">417</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line418">418</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line419">419</a>       # Checks the following cases:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line420">420</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line421">421</a>       # - table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line422">422</a>       # - &quot;table.name&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line423">423</a>       # - schema_name.table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line424">424</a>       # - schema_name.&quot;table.name&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line425">425</a>       # - &quot;schema.name&quot;.table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line426">426</a>       # - &quot;schema.name&quot;.&quot;table.name&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line427">427</a>       def quote_table_name(name)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line428">428</a>         schema, name_part = extract_pg_identifier_from_name(name.to_s)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line429">429</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line430">430</a>         unless name_part</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line431">431</a>           quote_column_name(schema)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line432">432</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line433">433</a>           table_name, name_part = extract_pg_identifier_from_name(name_part)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line434">434</a>           &quot;#{quote_column_name(schema)}.#{quote_column_name(table_name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line435">435</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line436">436</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line437">437</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line438">438</a>       # Quotes column names for use in SQL queries.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line439">439</a>       def quote_column_name(name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line440">440</a>         PGconn.quote_ident(name.to_s)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line441">441</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line442">442</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line443">443</a>       # Quote date/time values for use in SQL input. Includes microseconds</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line444">444</a>       # if the value is a Time responding to usec.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line445">445</a>       def quoted_date(value) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line446">446</a>         if value.acts_like?(:time) &amp;&amp; value.respond_to?(:usec)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line447">447</a>           &quot;#{super}.#{sprintf(&quot;%06d&quot;, value.usec)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line448">448</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line449">449</a>           super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line450">450</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line451">451</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line452">452</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line453">453</a>       # REFERENTIAL INTEGRITY ====================================</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line454">454</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line455">455</a>       def supports_disable_referential_integrity?() #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line456">456</a>         version = query(&quot;SHOW server_version&quot;)[0][0].split('.')</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line457">457</a>         (version[0].to_i &gt;= 8 &amp;&amp; version[1].to_i &gt;= 1) ? true : false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line458">458</a>       rescue</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line459">459</a>         return false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line460">460</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line461">461</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line462">462</a>       def disable_referential_integrity(&amp;block) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line463">463</a>         if supports_disable_referential_integrity?() then</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line464">464</a>           execute(tables.collect { |name| &quot;ALTER TABLE #{quote_table_name(name)} DISABLE TRIGGER ALL&quot; }.join(&quot;;&quot;))</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line465">465</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line466">466</a>         yield</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line467">467</a>       ensure</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line468">468</a>         if supports_disable_referential_integrity?() then</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line469">469</a>           execute(tables.collect { |name| &quot;ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER ALL&quot; }.join(&quot;;&quot;))</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line470">470</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line471">471</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line472">472</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line473">473</a>       # DATABASE STATEMENTS ======================================</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line474">474</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line475">475</a>       # Executes a SELECT query and returns an array of rows. Each row is an</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line476">476</a>       # array of field values.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line477">477</a>       def select_rows(sql, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line478">478</a>         select_raw(sql, name).last</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line479">479</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line480">480</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line481">481</a>       # Executes an INSERT query and returns the new record's ID</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line482">482</a>       def insert(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line483">483</a>         # Extract the table from the insert sql. Yuck.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line484">484</a>         table = sql.split(&quot; &quot;, 4)[2].gsub('&quot;', '')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line485">485</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line486">486</a>         # Try an insert with 'returning id' if available (PG &gt;= 8.2)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line487">487</a>         if supports_insert_with_returning?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line488">488</a>           pk, sequence_name = *pk_and_sequence_for(table) unless pk</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line489">489</a>           if pk</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line490">490</a>             id = select_value(&quot;#{sql} RETURNING #{quote_column_name(pk)}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line491">491</a>             clear_query_cache</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line492">492</a>             return id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line493">493</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line494">494</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line495">495</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line496">496</a>         # Otherwise, insert then grab last_insert_id.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line497">497</a>         if insert_id = super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line498">498</a>           insert_id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line499">499</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line500">500</a>           # If neither pk nor sequence name is given, look them up.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line501">501</a>           unless pk || sequence_name</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line502">502</a>             pk, sequence_name = *pk_and_sequence_for(table)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line503">503</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line504">504</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line505">505</a>           # If a pk is given, fallback to default sequence name.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line506">506</a>           # Don't fetch last insert id for a table without a pk.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line507">507</a>           if pk &amp;&amp; sequence_name ||= default_sequence_name(table, pk)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line508">508</a>             last_insert_id(table, sequence_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line509">509</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line510">510</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line511">511</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line512">512</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line513">513</a>       # create a 2D array representing the result set</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line514">514</a>       def result_as_array(res) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line515">515</a>         # check if we have any binary column and if they need escaping</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line516">516</a>         unescape_col = []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line517">517</a>         for j in 0...res.nfields do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line518">518</a>           # unescape string passed BYTEA field (OID == 17)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line519">519</a>           unescape_col &lt;&lt; ( res.ftype(j)==17 )</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line520">520</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line521">521</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line522">522</a>         ary = []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line523">523</a>         for i in 0...res.ntuples do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line524">524</a>           ary &lt;&lt; []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line525">525</a>           for j in 0...res.nfields do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line526">526</a>             data = res.getvalue(i,j)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line527">527</a>             data = unescape_bytea(data) if unescape_col[j] and data.is_a?(String)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line528">528</a>             ary[i] &lt;&lt; data</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line529">529</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line530">530</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line531">531</a>         return ary</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line532">532</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line533">533</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line534">534</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line535">535</a>       # Queries the database and returns the results in an Array-like object</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line536">536</a>       def query(sql, name = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line537">537</a>         log(sql, name) do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line538">538</a>           if @async</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line539">539</a>             res = @connection.async_exec(sql)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line540">540</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line541">541</a>             res = @connection.exec(sql)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line542">542</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line543">543</a>           return result_as_array(res)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line544">544</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line545">545</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line546">546</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line547">547</a>       # Executes an SQL statement, returning a PGresult object on success</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line548">548</a>       # or raising a PGError exception otherwise.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line549">549</a>       def execute(sql, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line550">550</a>         log(sql, name) do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line551">551</a>           if @async</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line552">552</a>             @connection.async_exec(sql)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line553">553</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line554">554</a>             @connection.exec(sql)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line555">555</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line556">556</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line557">557</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line558">558</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line559">559</a>       # Executes an UPDATE query and returns the number of affected tuples.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line560">560</a>       def update_sql(sql, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line561">561</a>         super.cmd_tuples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line562">562</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line563">563</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line564">564</a>       # Begins a transaction.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line565">565</a>       def begin_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line566">566</a>         execute &quot;BEGIN&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line567">567</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line568">568</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line569">569</a>       # Commits a transaction.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line570">570</a>       def commit_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line571">571</a>         execute &quot;COMMIT&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line572">572</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line573">573</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line574">574</a>       # Aborts a transaction.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line575">575</a>       def rollback_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line576">576</a>         execute &quot;ROLLBACK&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line577">577</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line578">578</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line579">579</a>       if defined?(PGconn::PQTRANS_IDLE)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line580">580</a>         # The ruby-pg driver supports inspecting the transaction status,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line581">581</a>         # while the ruby-postgres driver does not.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line582">582</a>         def outside_transaction?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line583">583</a>           @connection.transaction_status == PGconn::PQTRANS_IDLE</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line584">584</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line585">585</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line586">586</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line587">587</a>       def create_savepoint</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line588">588</a>         execute(&quot;SAVEPOINT #{current_savepoint_name}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line589">589</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line590">590</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line591">591</a>       def rollback_to_savepoint</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line592">592</a>         execute(&quot;ROLLBACK TO SAVEPOINT #{current_savepoint_name}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line593">593</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line594">594</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line595">595</a>       def release_savepoint</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line596">596</a>         execute(&quot;RELEASE SAVEPOINT #{current_savepoint_name}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line597">597</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line598">598</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line599">599</a>       # SCHEMA STATEMENTS ========================================</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line600">600</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line601">601</a>       def recreate_database(name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line602">602</a>         drop_database(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line603">603</a>         create_database(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line604">604</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line605">605</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line606">606</a>       # Create a new PostgreSQL database.  Options include &lt;tt&gt;:owner&lt;/tt&gt;, &lt;tt&gt;:template&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line607">607</a>       # &lt;tt&gt;:encoding&lt;/tt&gt;, &lt;tt&gt;:tablespace&lt;/tt&gt;, and &lt;tt&gt;:connection_limit&lt;/tt&gt; (note that MySQL uses</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line608">608</a>       # &lt;tt&gt;:charset&lt;/tt&gt; while PostgreSQL uses &lt;tt&gt;:encoding&lt;/tt&gt;).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line609">609</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line610">610</a>       # Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line611">611</a>       #   create_database config[:database], config</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line612">612</a>       #   create_database 'foo_development', :encoding =&gt; 'unicode'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line613">613</a>       def create_database(name, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line614">614</a>         options = options.reverse_merge(:encoding =&gt; &quot;utf8&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line615">615</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line616">616</a>         option_string = options.symbolize_keys.sum do |key, value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line617">617</a>           case key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line618">618</a>           when :owner</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line619">619</a>             &quot; OWNER = \&quot;#{value}\&quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line620">620</a>           when :template</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line621">621</a>             &quot; TEMPLATE = \&quot;#{value}\&quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line622">622</a>           when :encoding</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line623">623</a>             &quot; ENCODING = '#{value}'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line624">624</a>           when :tablespace</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line625">625</a>             &quot; TABLESPACE = \&quot;#{value}\&quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line626">626</a>           when :connection_limit</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line627">627</a>             &quot; CONNECTION LIMIT = #{value}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line628">628</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line629">629</a>             &quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line630">630</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line631">631</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line632">632</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line633">633</a>         execute &quot;CREATE DATABASE #{quote_table_name(name)}#{option_string}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line634">634</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line635">635</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line636">636</a>       # Drops a PostgreSQL database</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line637">637</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line638">638</a>       # Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line639">639</a>       #   drop_database 'matt_development'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line640">640</a>       def drop_database(name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line641">641</a>         if postgresql_version &gt;= 80200</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line642">642</a>           execute &quot;DROP DATABASE IF EXISTS #{quote_table_name(name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line643">643</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line644">644</a>           begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line645">645</a>             execute &quot;DROP DATABASE #{quote_table_name(name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line646">646</a>           rescue ActiveRecord::StatementInvalid</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line647">647</a>             @logger.warn &quot;#{name} database doesn't exist.&quot; if @logger</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line648">648</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line649">649</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line650">650</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line651">651</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line652">652</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line653">653</a>       # Returns the list of all tables in the schema search path or a specified schema.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line654">654</a>       def tables(name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line655">655</a>         schemas = schema_search_path.split(/,/).map { |p| quote(p) }.join(',')</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line656">656</a>         query(&lt;&lt;-SQL, name).map { |row| row[0] }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line657">657</a>           SELECT tablename</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line658">658</a>             FROM pg_tables</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line659">659</a>            WHERE schemaname IN (#{schemas})</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line660">660</a>         SQL</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line661">661</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line662">662</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line663">663</a>       # Returns the list of all indexes for a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line664">664</a>       def indexes(table_name, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line665">665</a>          schemas = schema_search_path.split(/,/).map { |p| quote(p) }.join(',')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line666">666</a>          result = query(&lt;&lt;-SQL, name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line667">667</a>            SELECT distinct i.relname, d.indisunique, d.indkey, t.oid</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line668">668</a>              FROM pg_class t, pg_class i, pg_index d</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line669">669</a>            WHERE i.relkind = 'i'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line670">670</a>              AND d.indexrelid = i.oid</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line671">671</a>              AND d.indisprimary = 'f'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line672">672</a>              AND t.oid = d.indrelid</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line673">673</a>              AND t.relname = '#{table_name}'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line674">674</a>              AND i.relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname IN (#{schemas}) )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line675">675</a>           ORDER BY i.relname</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line676">676</a>         SQL</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line677">677</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line678">678</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line679">679</a>         indexes = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line680">680</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line681">681</a>         indexes = result.map do |row|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line682">682</a>           index_name = row[0]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line683">683</a>           unique = row[1] == 't'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line684">684</a>           indkey = row[2].split(&quot; &quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line685">685</a>           oid = row[3]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line686">686</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line687">687</a>           columns = query(&lt;&lt;-SQL, &quot;Columns for index #{row[0]} on #{table_name}&quot;).inject({}) {|attlist, r| attlist[r[1]] = r[0]; attlist}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line688">688</a>           SELECT a.attname, a.attnum</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line689">689</a>           FROM pg_attribute a</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line690">690</a>           WHERE a.attrelid = #{oid}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line691">691</a>           AND a.attnum IN (#{indkey.join(&quot;,&quot;)})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line692">692</a>           SQL</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line693">693</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line694">694</a>           column_names = indkey.map {|attnum| columns[attnum] }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line695">695</a>           IndexDefinition.new(table_name, index_name, unique, column_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line696">696</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line697">697</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line698">698</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line699">699</a>         indexes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line700">700</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line701">701</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line702">702</a>       # Returns the list of all column definitions for a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line703">703</a>       def columns(table_name, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line704">704</a>         # Limit, precision, and scale are all handled by the superclass.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line705">705</a>         column_definitions(table_name).collect do |name, type, default, notnull|</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line706">706</a>           PostgreSQLColumn.new(name, default, type, notnull == 'f')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line707">707</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line708">708</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line709">709</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line710">710</a>       # Returns the current database name.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line711">711</a>       def current_database</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line712">712</a>         query('select current_database()')[0][0]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line713">713</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line714">714</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line715">715</a>       # Returns the current database encoding format.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line716">716</a>       def encoding</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line717">717</a>         query(&lt;&lt;-end_sql)[0][0]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line718">718</a>           SELECT pg_encoding_to_char(pg_database.encoding) FROM pg_database</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line719">719</a>           WHERE pg_database.datname LIKE '#{current_database}'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line720">720</a>         end_sql</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line721">721</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line722">722</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line723">723</a>       # Sets the schema search path to a string of comma-separated schema names.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line724">724</a>       # Names beginning with $ have to be quoted (e.g. $user =&gt; '$user').</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line725">725</a>       # See: http://www.postgresql.org/docs/current/static/ddl-schemas.html</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line726">726</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line727">727</a>       # This should be not be called manually but set in database.yml.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line728">728</a>       def schema_search_path=(schema_csv)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line729">729</a>         if schema_csv</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line730">730</a>           execute &quot;SET search_path TO #{schema_csv}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line731">731</a>           @schema_search_path = schema_csv</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line732">732</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line733">733</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line734">734</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line735">735</a>       # Returns the active schema search path.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line736">736</a>       def schema_search_path</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line737">737</a>         @schema_search_path ||= query('SHOW search_path')[0][0]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line738">738</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line739">739</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line740">740</a>       # Returns the current client message level.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line741">741</a>       def client_min_messages</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line742">742</a>         query('SHOW client_min_messages')[0][0]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line743">743</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line744">744</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line745">745</a>       # Set the client message level.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line746">746</a>       def client_min_messages=(level)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line747">747</a>         execute(&quot;SET client_min_messages TO '#{level}'&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line748">748</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line749">749</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line750">750</a>       # Returns the sequence name for a table's primary key or some other specified key.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line751">751</a>       def default_sequence_name(table_name, pk = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line752">752</a>         default_pk, default_seq = pk_and_sequence_for(table_name)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line753">753</a>         default_seq || &quot;#{table_name}_#{pk || default_pk || 'id'}_seq&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line754">754</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line755">755</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line756">756</a>       # Resets the sequence of a table's primary key to the maximum value.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line757">757</a>       def reset_pk_sequence!(table, pk = nil, sequence = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line758">758</a>         unless pk and sequence</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line759">759</a>           default_pk, default_sequence = pk_and_sequence_for(table)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line760">760</a>           pk ||= default_pk</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line761">761</a>           sequence ||= default_sequence</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line762">762</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line763">763</a>         if pk</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line764">764</a>           if sequence</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line765">765</a>             quoted_sequence = quote_column_name(sequence)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line766">766</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line767">767</a>             select_value &lt;&lt;-end_sql, 'Reset sequence'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line768">768</a>               SELECT setval('#{quoted_sequence}', (SELECT COALESCE(MAX(#{quote_column_name pk})+(SELECT increment_by FROM #{quoted_sequence}), (SELECT min_value FROM #{quoted_sequence})) FROM #{quote_table_name(table)}), false)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line769">769</a>             end_sql</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line770">770</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line771">771</a>             @logger.warn &quot;#{table} has primary key #{pk} with no default sequence&quot; if @logger</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line772">772</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line773">773</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line774">774</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line775">775</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line776">776</a>       # Returns a table's primary key and belonging sequence.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line777">777</a>       def pk_and_sequence_for(table) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line778">778</a>         # First try looking for a sequence with a dependency on the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line779">779</a>         # given table's primary key.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line780">780</a>         result = query(&lt;&lt;-end_sql, 'PK and serial sequence')[0]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line781">781</a>           SELECT attr.attname, seq.relname</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line782">782</a>           FROM pg_class      seq,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line783">783</a>                pg_attribute  attr,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line784">784</a>                pg_depend     dep,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line785">785</a>                pg_namespace  name,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line786">786</a>                pg_constraint cons</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line787">787</a>           WHERE seq.oid           = dep.objid</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line788">788</a>             AND seq.relkind       = 'S'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line789">789</a>             AND attr.attrelid     = dep.refobjid</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line790">790</a>             AND attr.attnum       = dep.refobjsubid</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line791">791</a>             AND attr.attrelid     = cons.conrelid</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line792">792</a>             AND attr.attnum       = cons.conkey[1]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line793">793</a>             AND cons.contype      = 'p'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line794">794</a>             AND dep.refobjid      = '#{quote_table_name(table)}'::regclass</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line795">795</a>         end_sql</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line796">796</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line797">797</a>         if result.nil? or result.empty?</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line798">798</a>           # If that fails, try parsing the primary key's default value.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line799">799</a>           # Support the 7.x and 8.0 nextval('foo'::text) as well as</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line800">800</a>           # the 8.1+ nextval('foo'::regclass).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line801">801</a>           result = query(&lt;&lt;-end_sql, 'PK and custom sequence')[0]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line802">802</a>             SELECT attr.attname,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line803">803</a>               CASE</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line804">804</a>                 WHEN split_part(def.adsrc, '''', 2) ~ '.' THEN</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line805">805</a>                   substr(split_part(def.adsrc, '''', 2),</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line806">806</a>                          strpos(split_part(def.adsrc, '''', 2), '.')+1)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line807">807</a>                 ELSE split_part(def.adsrc, '''', 2)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line808">808</a>               END</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line809">809</a>             FROM pg_class       t</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line810">810</a>             JOIN pg_attribute   attr ON (t.oid = attrelid)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line811">811</a>             JOIN pg_attrdef     def  ON (adrelid = attrelid AND adnum = attnum)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line812">812</a>             JOIN pg_constraint  cons ON (conrelid = adrelid AND adnum = conkey[1])</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line813">813</a>             WHERE t.oid = '#{quote_table_name(table)}'::regclass</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line814">814</a>               AND cons.contype = 'p'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line815">815</a>               AND def.adsrc ~* 'nextval'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line816">816</a>           end_sql</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line817">817</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line818">818</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line819">819</a>         # [primary_key, sequence]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line820">820</a>         [result.first, result.last]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line821">821</a>       rescue</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line822">822</a>         nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line823">823</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line824">824</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line825">825</a>       # Returns just a table's primary key</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line826">826</a>       def primary_key(table)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line827">827</a>         pk_and_sequence = pk_and_sequence_for(table)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line828">828</a>         pk_and_sequence &amp;&amp; pk_and_sequence.first</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line829">829</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line830">830</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line831">831</a>       # Renames a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line832">832</a>       def rename_table(name, new_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line833">833</a>         execute &quot;ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line834">834</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line835">835</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line836">836</a>       # Adds a new column to the named table.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line837">837</a>       # See TableDefinition#column for details of the options you can use.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line838">838</a>       def add_column(table_name, column_name, type, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line839">839</a>         default = options[:default]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line840">840</a>         notnull = options[:null] == false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line841">841</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line842">842</a>         # Add the column.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line843">843</a>         execute(&quot;ALTER TABLE #{quote_table_name(table_name)} ADD COLUMN #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line844">844</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line845">845</a>         change_column_default(table_name, column_name, default) if options_include_default?(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line846">846</a>         change_column_null(table_name, column_name, false, default) if notnull</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line847">847</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line848">848</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line849">849</a>       # Changes the column of a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line850">850</a>       def change_column(table_name, column_name, type, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line851">851</a>         quoted_table_name = quote_table_name(table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line852">852</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line853">853</a>         begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line854">854</a>           execute &quot;ALTER TABLE #{quoted_table_name} ALTER COLUMN #{quote_column_name(column_name)} TYPE #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line855">855</a>         rescue ActiveRecord::StatementInvalid =&gt; e</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line856">856</a>           raise e if postgresql_version &gt; 80000</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line857">857</a>           # This is PostgreSQL 7.x, so we have to use a more arcane way of doing it.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line858">858</a>           begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line859">859</a>             begin_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line860">860</a>             tmp_column_name = &quot;#{column_name}_ar_tmp&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line861">861</a>             add_column(table_name, tmp_column_name, type, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line862">862</a>             execute &quot;UPDATE #{quoted_table_name} SET #{quote_column_name(tmp_column_name)} = CAST(#{quote_column_name(column_name)} AS #{type_to_sql(type, options[:limit], options[:precision], options[:scale])})&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line863">863</a>             remove_column(table_name, column_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line864">864</a>             rename_column(table_name, tmp_column_name, column_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line865">865</a>             commit_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line866">866</a>           rescue</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line867">867</a>             rollback_db_transaction</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line868">868</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line869">869</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line870">870</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line871">871</a>         change_column_default(table_name, column_name, options[:default]) if options_include_default?(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line872">872</a>         change_column_null(table_name, column_name, options[:null], options[:default]) if options.key?(:null)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line873">873</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line874">874</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line875">875</a>       # Changes the default value of a table column.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line876">876</a>       def change_column_default(table_name, column_name, default)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line877">877</a>         execute &quot;ALTER TABLE #{quote_table_name(table_name)} ALTER COLUMN #{quote_column_name(column_name)} SET DEFAULT #{quote(default)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line878">878</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line879">879</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line880">880</a>       def change_column_null(table_name, column_name, null, default = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line881">881</a>         unless null || default.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line882">882</a>           execute(&quot;UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line883">883</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line884">884</a>         execute(&quot;ALTER TABLE #{quote_table_name(table_name)} ALTER #{quote_column_name(column_name)} #{null ? 'DROP' : 'SET'} NOT NULL&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line885">885</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line886">886</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line887">887</a>       # Renames a column in a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line888">888</a>       def rename_column(table_name, column_name, new_column_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line889">889</a>         execute &quot;ALTER TABLE #{quote_table_name(table_name)} RENAME COLUMN #{quote_column_name(column_name)} TO #{quote_column_name(new_column_name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line890">890</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line891">891</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line892">892</a>       # Drops an index from a table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line893">893</a>       def remove_index(table_name, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line894">894</a>         execute &quot;DROP INDEX #{quote_table_name(index_name(table_name, options))}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line895">895</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line896">896</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line897">897</a>       # Maps logical Rails types to PostgreSQL-specific data types.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line898">898</a>       def type_to_sql(type, limit = nil, precision = nil, scale = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line899">899</a>         return super unless type.to_s == 'integer'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line900">900</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line901">901</a>         case limit</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line902">902</a>           when 1..2;      'smallint'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line903">903</a>           when 3..4, nil; 'integer'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line904">904</a>           when 5..8;      'bigint'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line905">905</a>           else raise(ActiveRecordError, &quot;No integer type has byte size #{limit}. Use a numeric with precision 0 instead.&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line906">906</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line907">907</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line908">908</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line909">909</a>       # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line910">910</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line911">911</a>       # PostgreSQL requires the ORDER BY columns in the select list for distinct queries, and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line912">912</a>       # requires that the ORDER BY include the distinct column.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line913">913</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line914">914</a>       #   distinct(&quot;posts.id&quot;, &quot;posts.created_at desc&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line915">915</a>       def distinct(columns, order_by) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line916">916</a>         return &quot;DISTINCT #{columns}&quot; if order_by.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line917">917</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line918">918</a>         # Construct a clean list of column names from the ORDER BY clause, removing</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line919">919</a>         # any ASC/DESC modifiers</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line920">920</a>         order_columns = order_by.split(',').collect { |s| s.split.first }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line921">921</a>         order_columns.delete_if &amp;:blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line922">922</a>         order_columns = order_columns.zip((0...order_columns.size).to_a).map { |s,i| &quot;#{s} AS alias_#{i}&quot; }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line923">923</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line924">924</a>         # Return a DISTINCT ON() clause that's distinct on the columns we want but includes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line925">925</a>         # all the required columns for the ORDER BY to work properly.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line926">926</a>         sql = &quot;DISTINCT ON (#{columns}) #{columns}, &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line927">927</a>         sql &lt;&lt; order_columns * ', '</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line928">928</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line929">929</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line930">930</a>       # Returns an ORDER BY clause for the passed order option.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line931">931</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line932">932</a>       # PostgreSQL does not allow arbitrary ordering when using DISTINCT ON, so we work around this</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line933">933</a>       # by wrapping the +sql+ string as a sub-select and ordering in that query.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line934">934</a>       def add_order_by_for_association_limiting!(sql, options) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line935">935</a>         return sql if options[:order].blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line936">936</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line937">937</a>         order = options[:order].split(',').collect { |s| s.strip }.reject(&amp;:blank?)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line938">938</a>         order.map! { |s| 'DESC' if s =~ /\bdesc$/i }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line939">939</a>         order = order.zip((0...order.size).to_a).map { |s,i| &quot;id_list.alias_#{i} #{s}&quot; }.join(', ')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line940">940</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line941">941</a>         sql.replace &quot;SELECT * FROM (#{sql}) AS id_list ORDER BY #{order}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line942">942</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line943">943</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line944">944</a>       protected</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line945">945</a>         # Returns the version of the connected PostgreSQL version.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line946">946</a>         def postgresql_version</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line947">947</a>           @postgresql_version ||=</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line948">948</a>             if @connection.respond_to?(:server_version)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line949">949</a>               @connection.server_version</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line950">950</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line951">951</a>               # Mimic PGconn.server_version behavior</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line952">952</a>               begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line953">953</a>                 query('SELECT version()')[0][0] =~ /PostgreSQL (\d+)\.(\d+)\.(\d+)/</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line954">954</a>                 ($1.to_i * 10000) + ($2.to_i * 100) + $3.to_i</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line955">955</a>               rescue</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line956">956</a>                 0</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line957">957</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line958">958</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line959">959</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line960">960</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line961">961</a>       private</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line962">962</a>         # The internal PostgreSQL identifier of the money data type.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line963">963</a>         MONEY_COLUMN_TYPE_OID = 790 #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line964">964</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line965">965</a>         # Connects to a PostgreSQL server and sets up the adapter depending on the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line966">966</a>         # connected server's characteristics.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line967">967</a>         def connect</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line968">968</a>           @connection = PGconn.connect(*@connection_parameters)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line969">969</a>           PGconn.translate_results = false if PGconn.respond_to?(:translate_results=)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line970">970</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line971">971</a>           # Ignore async_exec and async_query when using postgres-pr.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line972">972</a>           @async = @config[:allow_concurrency] &amp;&amp; @connection.respond_to?(:async_exec)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line973">973</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line974">974</a>           # Use escape string syntax if available. We cannot do this lazily when encountering</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line975">975</a>           # the first string, because that could then break any transactions in progress.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line976">976</a>           # See: http://www.postgresql.org/docs/current/static/runtime-config-compatible.html</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line977">977</a>           # If PostgreSQL doesn't know the standard_conforming_strings parameter then it doesn't</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line978">978</a>           # support escape string syntax. Don't override the inherited quoted_string_prefix.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line979">979</a>           if supports_standard_conforming_strings?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line980">980</a>             self.class.instance_eval do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line981">981</a>               define_method(:quoted_string_prefix) { 'E' }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line982">982</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line983">983</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line984">984</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line985">985</a>           # Money type has a fixed precision of 10 in PostgreSQL 8.2 and below, and as of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line986">986</a>           # PostgreSQL 8.3 it has a fixed precision of 19. PostgreSQLColumn.extract_precision</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line987">987</a>           # should know about this but can't detect it there, so deal with it here.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line988">988</a>           money_precision = (postgresql_version &gt;= 80300) ? 19 : 10</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line989">989</a>           PostgreSQLColumn.module_eval(&lt;&lt;-end_eval)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line990">990</a>             def extract_precision(sql_type)  # def extract_precision(sql_type)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line991">991</a>               if sql_type =~ /^money$/       #   if sql_type =~ /^money$/</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line992">992</a>                 #{money_precision}           #     19</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line993">993</a>               else                           #   else</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line994">994</a>                 super                        #     super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line995">995</a>               end                            #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line996">996</a>             end                              # end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line997">997</a>           end_eval</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line998">998</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line999">999</a>           configure_connection</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1000">1000</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1001">1001</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1002">1002</a>         # Configures the encoding, verbosity, and schema search path of the connection.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1003">1003</a>         # This is called by #connect and should not be called manually.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1004">1004</a>         def configure_connection</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1005">1005</a>           if @config[:encoding]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1006">1006</a>             if @connection.respond_to?(:set_client_encoding)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1007">1007</a>               @connection.set_client_encoding(@config[:encoding])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1008">1008</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1009">1009</a>               execute(&quot;SET client_encoding TO '#{@config[:encoding]}'&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1010">1010</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1011">1011</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1012">1012</a>           self.client_min_messages = @config[:min_messages] if @config[:min_messages]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1013">1013</a>           self.schema_search_path = @config[:schema_search_path] || @config[:schema_order]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1014">1014</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1015">1015</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1016">1016</a>         # Returns the current ID of a table's sequence.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1017">1017</a>         def last_insert_id(table, sequence_name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1018">1018</a>           Integer(select_value(&quot;SELECT currval('#{sequence_name}')&quot;))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1019">1019</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1020">1020</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1021">1021</a>         # Executes a SELECT query and returns the results, performing any data type</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1022">1022</a>         # conversions that are required to be performed here instead of in PostgreSQLColumn.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1023">1023</a>         def select(sql, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1024">1024</a>           fields, rows = select_raw(sql, name)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1025">1025</a>           result = []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1026">1026</a>           for row in rows</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1027">1027</a>             row_hash = {}</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1028">1028</a>             fields.each_with_index do |f, i|</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1029">1029</a>               row_hash[f] = row[i]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1030">1030</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1031">1031</a>             result &lt;&lt; row_hash</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1032">1032</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1033">1033</a>           result</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1034">1034</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1035">1035</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1036">1036</a>         def select_raw(sql, name = nil)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1037">1037</a>           res = execute(sql, name)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1038">1038</a>           results = result_as_array(res)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1039">1039</a>           fields = []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1040">1040</a>           rows = []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1041">1041</a>           if res.ntuples &gt; 0</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1042">1042</a>             fields = res.fields</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1043">1043</a>             results.each do |row|</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1044">1044</a>               hashed_row = {}</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1045">1045</a>               row.each_index do |cell_index|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1046">1046</a>                 # If this is a money type column and there are any currency symbols,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1047">1047</a>                 # then strip them off. Indeed it would be prettier to do this in</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1048">1048</a>                 # PostgreSQLColumn.string_to_decimal but would break form input</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1049">1049</a>                 # fields that call value_before_type_cast.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1050">1050</a>                 if res.ftype(cell_index) == MONEY_COLUMN_TYPE_OID</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1051">1051</a>                   # Because money output is formatted according to the locale, there are two</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1052">1052</a>                   # cases to consider (note the decimal separators):</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1053">1053</a>                   #  (1) $12,345,678.12</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1054">1054</a>                   #  (2) $12.345.678,12</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1055">1055</a>                   case column = row[cell_index]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1056">1056</a>                     when /^-?\D+[\d,]+\.\d{2}$/  # (1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1057">1057</a>                       row[cell_index] = column.gsub(/[^-\d\.]/, '')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1058">1058</a>                     when /^-?\D+[\d\.]+,\d{2}$/  # (2)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1059">1059</a>                       row[cell_index] = column.gsub(/[^-\d,]/, '').sub(/,/, '.')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1060">1060</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1061">1061</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1062">1062</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1063">1063</a>                 hashed_row[fields[cell_index]] = column</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1064">1064</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1065">1065</a>               rows &lt;&lt; row</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1066">1066</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1067">1067</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1068">1068</a>           res.clear</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1069">1069</a>           return fields, rows</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1070">1070</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1071">1071</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1072">1072</a>         # Returns the list of a table's column names, data types, and default values.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1073">1073</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1074">1074</a>         # The underlying query is roughly:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1075">1075</a>         #  SELECT column.name, column.type, default.value</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1076">1076</a>         #    FROM column LEFT JOIN default</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1077">1077</a>         #      ON column.table_id = default.table_id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1078">1078</a>         #     AND column.num = default.column_num</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1079">1079</a>         #   WHERE column.table_id = get_table_id('table_name')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1080">1080</a>         #     AND column.num &gt; 0</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1081">1081</a>         #     AND NOT column.is_dropped</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1082">1082</a>         #   ORDER BY column.num</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1083">1083</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1084">1084</a>         # If the table name is not prefixed with a schema, the database will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1085">1085</a>         # take the first match from the schema search path.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1086">1086</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1087">1087</a>         # Query implementation notes:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1088">1088</a>         #  - format_type includes the column size constraint, e.g. varchar(50)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1089">1089</a>         #  - ::regclass is a function that gives the id for a table name</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1090">1090</a>         def column_definitions(table_name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1091">1091</a>           query &lt;&lt;-end_sql</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1092">1092</a>             SELECT a.attname, format_type(a.atttypid, a.atttypmod), d.adsrc, a.attnotnull</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1093">1093</a>               FROM pg_attribute a LEFT JOIN pg_attrdef d</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1094">1094</a>                 ON a.attrelid = d.adrelid AND a.attnum = d.adnum</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1095">1095</a>              WHERE a.attrelid = '#{quote_table_name(table_name)}'::regclass</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1096">1096</a>                AND a.attnum &gt; 0 AND NOT a.attisdropped</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1097">1097</a>              ORDER BY a.attnum</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1098">1098</a>           end_sql</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1099">1099</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1100">1100</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1101">1101</a>         def extract_pg_identifier_from_name(name)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1102">1102</a>           match_data = name[0,1] == '&quot;' ? name.match(/\&quot;([^\&quot;]+)\&quot;/) : name.match(/([^\.]+)/)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1103">1103</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1104">1104</a>           if match_data</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1105">1105</a>             rest = name[match_data[0].length..-1]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1106">1106</a>             rest = rest[1..-1] if rest[0,1] == &quot;.&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1107">1107</a>             [match_data[1], (rest.length &gt; 0 ? rest : nil)]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1108">1108</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1109">1109</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1110">1110</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1111">1111</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1112">1112</a> end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1113">1113</a> </pre></td>
          </tr>
        
      </tbody>
    </table>

    <p>Generated on Thu Jan 07 11:14:14 +0100 2010 with <a href="http://github.com/relevance/rcov">rcov 0.9.6</a></p>

  </body>
</html>
